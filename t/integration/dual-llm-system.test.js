// Generated by CoffeeScript 2.7.0
(function() {
  // Integration Tests - Full System
  var afterEach, assert, axios, beforeEach, createMockNeo4jDriver, createMockOllamaResponse, createMockSocket, describe, it, mock, socketClient, waitForPromises;

  ({describe, it, beforeEach, afterEach, mock} = require('node:test'));

  assert = require('node:assert');

  ({createMockOllamaResponse, createMockNeo4jDriver, createMockSocket, waitForPromises} = require('../setup'));

  axios = require('axios');

  socketClient = require('socket.io-client');

  // Mock all external dependencies
  mock.module('axios');

  mock.module('socket.io-client');

  mock.module('neo4j-driver', function() {
    return {
      driver: mock.fn().mock.mockImplementation(function() {
        return createMockNeo4jDriver();
      }),
      auth: {
        basic: mock.fn()
      }
    };
  });

  describe('Dual LLM System Integration', function() {
    var app, baseURL, mockSocket;
    app = null;
    mockSocket = null;
    baseURL = 'http://localhost:3001';
    beforeEach(function() {
      // Set test environment
      process.env.PORT = '3001';
      process.env.NODE_ENV = 'test';
      // Mock Ollama responses
      axios.post.mock.mockImplementation(function(url, data) {
        var content, model;
        if (url.includes('/api/generate')) {
          model = data.model;
          content = model.includes('alpha') ? 'Analytical response: ' + data.prompt : 'Creative response: ' + data.prompt;
          return Promise.resolve(createMockOllamaResponse(content));
        }
        return Promise.reject(new Error('Unknown endpoint'));
      });
      axios.get.mock.mockImplementation(function(url) {
        if (url.includes('/api/tags')) {
          return Promise.resolve({
            data: {
              models: [
                {
                  name: 'llama3.1:8b-instruct-q4_K_M'
                },
                {
                  name: 'qwen2.5-coder:7b-instruct-q4_K_M'
                }
              ]
            }
          });
        }
        return Promise.reject(new Error('Unknown endpoint'));
      });
      // Create app instance
      app = new DualLLMApp();
      // Mock socket client
      mockSocket = createMockSocket();
      return socketClient.connect.mock.mockImplementation(function() {
        return mockSocket;
      });
    });
    afterEach(async function() {
      var ref;
      // Clean up
      if (app != null ? (ref = app.server) != null ? ref.listening : void 0 : void 0) {
        await new Promise(function(resolve) {
          return app.server.close(resolve);
        });
      }
      return vi.clearAllMocks();
    });
    describe('Application Startup', function() {
      it('should initialize and start successfully', async function() {
        await app.initialize();
        // Check services initialized
        assert.ok(app.llmAlpha);
        assert.ok(app.llmBeta);
        assert.ok(app.corpusCallosum);
        assert.ok(app.neo4jTool);
        assert.ok(app.messageRouter);
        // Start server
        await new Promise(function(resolve) {
          app.start();
          return setTimeout(resolve, 100);
        });
        return assert.equal(app.server.listening, true);
      });
      return it('should handle initialization errors gracefully', async function() {
        var neo4j;
        // Make Neo4j connection fail
        neo4j = require('neo4j-driver');
        neo4j.driver.mockImplementationOnce(function() {
          throw new Error('Connection failed');
        });
        return (await expect(app.initialize()).rejects.toThrow('Connection failed'));
      });
    });
    describe('REST API Endpoints', function() {
      beforeEach(async function() {
        await app.initialize();
        app.start();
        return (await waitForPromises());
      });
      it('should process chat messages via API', async function() {
        var response;
        response = (await axios.post(`${baseURL}/api/chat/message`, {
          message: 'Hello world',
          mode: 'parallel'
        }));
        return assert.deepEqual(response.data, {
          conversationId: expect.any(String),
          userMessage: {
            content: 'Hello world',
            sender: 'user'
          },
          alphaResponse: expect.any(Object),
          betaResponse: expect.any(Object)
        });
      });
      it('should get model information', async function() {
        var response;
        response = (await axios.get(`${baseURL}/api/models`));
        return assert.deepEqual(response.data, {
          alpha: {
            model: 'llama3.1:8b-instruct-q4_K_M',
            role: 'analytical',
            available: true
          },
          beta: {
            model: 'qwen2.5-coder:7b-instruct-q4_K_M',
            role: 'creative',
            available: true
          }
        });
      });
      return it('should check health status', async function() {
        var response;
        response = (await axios.get(`${baseURL}/health`));
        return assert.deepEqual(response.data, {
          status: 'ok',
          timestamp: expect.any(String),
          services: {
            alpha: 'healthy',
            beta: 'healthy',
            neo4j: 'connected'
          }
        });
      });
    });
    describe('WebSocket Communication', function() {
      beforeEach(async function() {
        await app.initialize();
        app.start();
        return (await waitForPromises());
      });
      it('should handle message flow through websockets', async function() {
        var alphaEmission, betaEmission, connectionHandler, emissions, messageHandler, ref, ref1;
        // Simulate connection
        connectionHandler = (ref = app.io.on.mock.calls[0]) != null ? ref[1] : void 0;
        if (typeof connectionHandler === "function") {
          connectionHandler(mockSocket);
        }
        // Simulate message send
        messageHandler = (ref1 = mockSocket.on.mock.calls.find(function(call) {
          return call[0] === 'message_send';
        })) != null ? ref1[1] : void 0;
        await (typeof messageHandler === "function" ? messageHandler({
          message: 'Test websocket message',
          mode: 'parallel'
        }) : void 0);
        // Check emissions
        emissions = mockSocket.getEmitted();
        // Should emit both responses
        alphaEmission = emissions.find(function(e) {
          return e.event === 'alpha_response';
        });
        betaEmission = emissions.find(function(e) {
          return e.event === 'beta_response';
        });
        assert.ok(alphaEmission);
        expect(alphaEmission.data.content).toContain('Analytical response');
        assert.ok(betaEmission);
        return expect(betaEmission.data.content).toContain('Creative response');
      });
      it('should handle synthesis mode', async function() {
        var connectionHandler, emissions, messageHandler, ref, ref1, synthesisEmission;
        connectionHandler = (ref = app.io.on.mock.calls[0]) != null ? ref[1] : void 0;
        if (typeof connectionHandler === "function") {
          connectionHandler(mockSocket);
        }
        messageHandler = (ref1 = mockSocket.on.mock.calls.find(function(call) {
          return call[0] === 'message_send';
        })) != null ? ref1[1] : void 0;
        await (typeof messageHandler === "function" ? messageHandler({
          message: 'Synthesize this',
          mode: 'synthesis'
        }) : void 0);
        emissions = mockSocket.getEmitted();
        synthesisEmission = emissions.find(function(e) {
          return e.event === 'synthesis_complete';
        });
        assert.ok(synthesisEmission);
        return assert.equal(synthesisEmission.data.mode, 'synthesis');
      });
      return it('should handle handoff mode correctly', async function() {
        var clearBetaEmission, completionEmission, connectionHandler, emissions, messageHandler, ref, ref1;
        // Mock handoff response
        app.corpusCallosum.orchestrate = mock.fn().mockResolvedValue({
          alphaResponse: {
            content: 'Alpha handled this'
          },
          betaResponse: null,
          primary: 'alpha',
          communications: []
        });
        connectionHandler = (ref = app.io.on.mock.calls[0]) != null ? ref[1] : void 0;
        if (typeof connectionHandler === "function") {
          connectionHandler(mockSocket);
        }
        messageHandler = (ref1 = mockSocket.on.mock.calls.find(function(call) {
          return call[0] === 'message_send';
        })) != null ? ref1[1] : void 0;
        await (typeof messageHandler === "function" ? messageHandler({
          message: 'Analyze this data',
          mode: 'handoff'
        }) : void 0);
        emissions = mockSocket.getEmitted();
        // Should clear beta thinking
        clearBetaEmission = emissions.find(function(e) {
          return e.event === 'clear_beta_thinking';
        });
        assert.ok(clearBetaEmission);
        // Should emit completion
        completionEmission = emissions.find(function(e) {
          return e.event === 'interaction_complete';
        });
        assert.ok(completionEmission);
        return assert.equal(completionEmission.data.primary, 'alpha');
      });
    });
    describe('Communication Modes', function() {
      beforeEach(async function() {
        await app.initialize();
        app.start();
        return (await waitForPromises());
      });
      return it('should switch between modes dynamically', async function() {
        var callCount, result1, result2;
        // Test parallel mode
        result1 = (await app.messageRouter.processMessage('Test parallel', 'parallel'));
        assert.ok(result1.alphaResponse);
        assert.ok(result1.betaResponse);
        // Switch to sequential
        app.corpusCallosum.setMode('sequential');
        // Mock sequential behavior
        callCount = 0;
        axios.post.mock.mockImplementation(function(url, data) {
          var content;
          if (url.includes('/api/generate')) {
            callCount++;
            content = callCount === 1 ? 'First response' : 'Second response with context';
            return Promise.resolve(createMockOllamaResponse(content));
          }
          return Promise.reject(new Error('Unknown'));
        });
        result2 = (await app.messageRouter.processMessage('Test sequential', 'sequential'));
        return assert.equal(axios.post.mock.calls.length, 2);
      });
    });
    describe('Neo4j Integration', function() {
      beforeEach(async function() {
        await app.initialize();
        app.start();
        return (await waitForPromises());
      });
      it('should store conversations in Neo4j', async function() {
        var conversationQuery, messageQueries, neo4jDriver, queries, sessions;
        await app.messageRouter.processMessage('Test message');
        // Check Neo4j calls
        neo4jDriver = app.neo4jTool.driver;
        sessions = neo4jDriver.getSessions();
        // Should have created conversation and messages
        queries = sessions.flatMap(function(s) {
          return s.run.mock.calls;
        });
        conversationQuery = queries.find(function(call) {
          return call[0].includes('CREATE (c:Conversation');
        });
        assert.ok(conversationQuery);
        messageQueries = queries.filter(function(call) {
          return call[0].includes('CREATE (m:Message');
        });
        return expect(messageQueries.length).toBeGreaterThan(0);
      });
      return it('should extract and store knowledge', async function() {
        var entityNames, entityQueries, queries, sessions;
        await app.messageRouter.processMessage('Tell me about Claude and Anthropic');
        sessions = app.neo4jTool.driver.getSessions();
        queries = sessions.flatMap(function(s) {
          return s.run.mock.calls;
        });
        entityQueries = queries.filter(function(call) {
          return call[0].includes('MERGE (e:Entity');
        });
        // Should have extracted entities
        expect(entityQueries.length).toBeGreaterThan(0);
        // Check for specific entities
        entityNames = entityQueries.map(function(call) {
          return call[1].name;
        });
        expect(entityNames).toContain('Claude');
        return expect(entityNames).toContain('Anthropic');
      });
    });
    describe('Error Handling', function() {
      beforeEach(async function() {
        await app.initialize();
        app.start();
        return (await waitForPromises());
      });
      it('should handle Ollama connection errors', async function() {
        var response;
        axios.post.mock.mockImplementation(function() {
          return Promise.reject(new Error('ECONNREFUSED'));
        });
        response = (await axios.post(`${baseURL}/api/chat/message`, {
          message: 'Test'
        }).catch(function(e) {
          return e.response;
        }));
        assert.equal(response.status, 500);
        return expect(response.data.error).toContain('Cannot connect to Ollama');
      });
      return it('should handle websocket errors gracefully', async function() {
        var connectionHandler, emissions, errorEmission, messageHandler, ref, ref1;
        connectionHandler = (ref = app.io.on.mock.calls[0]) != null ? ref[1] : void 0;
        if (typeof connectionHandler === "function") {
          connectionHandler(mockSocket);
        }
        // Make orchestration fail
        app.corpusCallosum.orchestrate = mock.fn().mockRejectedValue(new Error('Orchestration failed'));
        messageHandler = (ref1 = mockSocket.on.mock.calls.find(function(call) {
          return call[0] === 'message_send';
        })) != null ? ref1[1] : void 0;
        await (typeof messageHandler === "function" ? messageHandler({
          message: 'Test'
        }) : void 0);
        emissions = mockSocket.getEmitted();
        errorEmission = emissions.find(function(e) {
          return e.event === 'error';
        });
        assert.ok(errorEmission);
        return assert.equal(errorEmission.data.message, 'Orchestration failed');
      });
    });
    return describe('Concurrent Requests', function() {
      beforeEach(async function() {
        await app.initialize();
        app.start();
        return (await waitForPromises());
      });
      it('should handle multiple simultaneous requests', async function() {
        var conversationIds, promises, results, uniqueIds;
        // Send multiple requests concurrently
        promises = [1, 2, 3, 4, 5].map(function(i) {
          return app.messageRouter.processMessage(`Message ${i}`, 'parallel');
        });
        results = (await Promise.all(promises));
        // All should succeed
        expect(results).toHaveLength(5);
        // Each should have unique conversation ID
        conversationIds = results.map(function(r) {
          return r.conversationId;
        });
        uniqueIds = new Set(conversationIds);
        return assert.equal(uniqueIds.size, 5);
      });
      return it('should handle rapid mode switching', async function() {
        var modes, promises, results;
        modes = ['parallel', 'sequential', 'debate', 'synthesis', 'handoff'];
        promises = modes.map(function(mode, i) {
          return app.messageRouter.processMessage(`Test ${mode}`, mode);
        });
        results = (await Promise.all(promises));
        // All modes should work
        expect(results).toHaveLength(5);
        return results.forEach(function(result, i) {
          return assert.equal(result.mode, modes[i]);
        });
      });
    });
  });

}).call(this);
