// Generated by CoffeeScript 2.7.0
(function() {
  // Neo4j Tool Tests
  var Neo4jTool, assert, beforeEach, createMockNeo4jDriver, describe, it, mock;

  ({describe, it, beforeEach, mock} = require('node:test'));

  assert = require('node:assert');

  Neo4jTool = require('../../src/services/neo4j-tool');

  ({createMockNeo4jDriver} = require('../setup'));

  describe('Neo4jTool', function() {
    var mockDatabaseConfig, mockDriver, neo4jTool;
    mockDriver = null;
    mockDatabaseConfig = null;
    neo4jTool = null;
    beforeEach(function() {
      mockDriver = createMockNeo4jDriver();
      mockDatabaseConfig = {
        connect: mock.fn(),
        getDriver: mock.fn(),
        close: mock.fn()
      };
      // Set default mock implementations
      mockDatabaseConfig.connect.mock.mockImplementation(function() {
        return Promise.resolve(mockDriver);
      });
      mockDatabaseConfig.getDriver.mock.mockImplementation(function() {
        return mockDriver;
      });
      mockDatabaseConfig.close.mock.mockImplementation(function() {
        return Promise.resolve(void 0);
      });
      return neo4jTool = new Neo4jTool(mockDatabaseConfig);
    });
    describe('constructor', function() {
      return it('should initialize with database config', function() {
        assert.equal(neo4jTool.databaseConfig, mockDatabaseConfig);
        assert.equal(neo4jTool.driver, null);
        assert.equal(neo4jTool.session, null);
        return assert.deepEqual(neo4jTool.schema, {});
      });
    });
    describe('connect', function() {
      it('should connect and initialize schema', async function() {
        var indexQueries, result, runCalls, sessions;
        result = (await neo4jTool.connect());
        assert.equal(result, true);
        assert.ok(mockDatabaseConfig.connect.mock.calls.length > 0);
        assert.equal(neo4jTool.driver, mockDriver);
        // Should create indexes
        sessions = mockDriver.getSessions();
        assert.ok(sessions.length > 0);
        // Check for index creation queries
        runCalls = sessions[0].run.mock.calls;
        indexQueries = runCalls.filter(function(call) {
          return call.arguments[0].includes('CREATE INDEX');
        });
        return assert.equal(indexQueries.length, 4); // 4 indexes
      });
      return it('should handle connection errors', async function() {
        mockDatabaseConfig.connect.mock.mockImplementation(function() {
          return Promise.reject(new Error('Connection failed'));
        });
        return (await assert.rejects(neo4jTool.connect(), {
          message: 'Connection failed'
        }));
      });
    });
    return describe('executeQuery', function() {
      beforeEach(async function() {
        return (await neo4jTool.connect());
      });
      it('should execute query and return results', async function() {
        var mockSession, result;
        mockSession = mockDriver.getSessions()[0];
        mockSession.run.mock.mockImplementation(function() {
          return Promise.resolve({
            records: [
              {
                keys: ['name',
              'age'],
                get: function(key) {
                  if (key === 'name') {
                    return 'Alice';
                  } else {
                    return 25;
                  }
                }
              },
              {
                keys: ['name',
              'age'],
                get: function(key) {
                  if (key === 'name') {
                    return 'Bob';
                  } else {
                    return 30;
                  }
                }
              }
            ],
            summary: {
              counters: {
                nodesCreated: 2
              },
              resultAvailableAfter: 5,
              resultConsumedAfter: 10
            }
          });
        });
        result = (await neo4jTool.executeQuery('MATCH (n:Person) RETURN n.name as name, n.age as age', {}));
        assert.deepEqual(result.records, [
          {
            name: 'Alice',
            age: 25
          },
          {
            name: 'Bob',
            age: 30
          }
        ]);
        assert.equal(result.summary.counters.nodesCreated, 2);
        return assert.ok(mockSession.close.mock.calls.length > 0);
      });
      it('should handle query parameters', async function() {
        var session;
        await neo4jTool.executeQuery('MATCH (n:Person {name: $name}) RETURN n', {
          name: 'Alice'
        });
        session = mockDriver.getSessions()[0];
        assert.equal(session.run.mock.calls[0].arguments[0], 'MATCH (n:Person {name: $name}) RETURN n');
        return assert.deepEqual(session.run.mock.calls[0].arguments[1], {
          name: 'Alice'
        });
      });
      it('should close session even on error', async function() {
        var mockSession;
        mockSession = mockDriver.getSessions()[0];
        mockSession.run.mock.mockImplementation(function() {
          return Promise.reject(new Error('Query failed'));
        });
        await assert.rejects(neo4jTool.executeQuery('INVALID QUERY'), {
          message: 'Query failed'
        });
        return assert.ok(mockSession.close.mock.calls.length > 0);
      });
      return it('should create new session if not connected', async function() {
        neo4jTool.driver = null; // Reset connection
        await neo4jTool.executeQuery('MATCH (n) RETURN n');
        return assert.ok(mockDatabaseConfig.connect.mock.calls.length > 0);
      });
    });
  });

  // Add more test cases as needed...

}).call(this);
