// Generated by CoffeeScript 2.7.0
(function() {
  // Mode Executors - Each mode as its own class

  // Base class for all mode executors
  var DebateExecutor, HandoffExecutor, ModeExecutor, ParallelExecutor, PromptBuilder, RolePlayExecutor, SequentialExecutor, SynthesisExecutor;

  ModeExecutor = class ModeExecutor {
    constructor(alpha1, beta1, config1) {
      this.alpha = alpha1;
      this.beta = beta1;
      this.config = config1;
      this.promptBuilder = new PromptBuilder();
    }

    execute(message, processId, recordComm) {
      throw new Error("Subclasses must implement execute()");
    }

    extractContent(response) {
      if (typeof response === 'string') {
        return response;
      } else {
        return response.content;
      }
    }

    withTimeout(promise, timeoutMs) {
      return Promise.race([
        promise,
        new Promise(function(_,
        reject) {
          return setTimeout((function() {
            return reject(new Error('Timeout'));
          }),
        timeoutMs);
        })
      ]);
    }

    delay(ms) {
      return new Promise(function(resolve) {
        return setTimeout(resolve, ms);
      });
    }

  };

  // Parallel Mode - Both brains process simultaneously
  ParallelExecutor = class ParallelExecutor extends ModeExecutor {
    async execute(message, processId, recordComm) {
      var promises, results;
      promises = [this.withTimeout(this.alpha.processMessage(message, null), this.config.timeout), this.withTimeout(this.beta.processMessage(message, null), this.config.timeout)];
      results = (await Promise.allSettled(promises));
      return this.buildResponse(results);
    }

    buildResponse(results) {
      var alphaResult, betaResult;
      [alphaResult, betaResult] = results;
      if (alphaResult.status === 'rejected') {
        console.error('Alpha failed:', alphaResult.reason);
      }
      if (betaResult.status === 'rejected') {
        console.error('Beta failed:', betaResult.reason);
      }
      return {
        alphaResponse: alphaResult.status === 'fulfilled' ? alphaResult.value : null,
        betaResponse: betaResult.status === 'fulfilled' ? betaResult.value : null
      };
    }

  };

  // Sequential Mode - One brain, then the other
  SequentialExecutor = class SequentialExecutor extends ModeExecutor {
    constructor(alpha, beta, config) {
      super(alpha, beta, config);
      this.defaultOrder = config.modes.sequential.default_order;
      this.handoffDelay = config.modes.sequential.handoff_delay;
    }

    async execute(message, processId, recordComm, order = null) {
      var contextMessage, firstContent, firstModel, firstResponse, models, responses, secondModel, secondResponse;
      order = order || this.defaultOrder;
      models = {
        alpha: this.alpha,
        beta: this.beta
      };
      // First model
      firstModel = models[order[0]];
      firstResponse = (await firstModel.processMessage(message, null));
      // Delay between models
      await this.delay(this.handoffDelay);
      // Second model with context
      firstContent = this.extractContent(firstResponse);
      contextMessage = this.buildContextMessage(message, order[0], firstContent);
      secondModel = models[order[1]];
      secondResponse = (await secondModel.processMessage(contextMessage, firstResponse));
      // Record handoff
      recordComm({
        from: order[0],
        to: order[1],
        message: firstContent,
        type: 'handoff'
      });
      // Build response
      responses = {};
      responses[order[0]] = firstResponse;
      responses[order[1]] = secondResponse;
      return {
        alphaResponse: responses.alpha,
        betaResponse: responses.beta
      };
    }

    buildContextMessage(originalMessage, fromModel, content) {
      return `${originalMessage}

Context from ${fromModel}: ${content}`;
    }

  };

  // Debate Mode - Iterative refinement through challenges
  DebateExecutor = class DebateExecutor extends ModeExecutor {
    constructor(alpha, beta, config) {
      super(alpha, beta, config);
      this.maxRounds = config.modes.debate.max_rounds;
      this.convergenceThreshold = config.modes.debate.convergence_threshold;
    }

    async execute(message, processId, recordComm) {
      var i, ref, result, round, state;
      state = (await this.initializeDebate(message));
      for (round = i = 1, ref = this.maxRounds; (1 <= ref ? i <= ref : i >= ref); round = 1 <= ref ? ++i : --i) {
        result = (await this.runDebateRound(message, state, round, recordComm));
        if (this.hasConverged(state.previousContent, result.refinedContent)) {
          console.log(`Debate converged after ${round} rounds`);
          break;
        }
        state = this.updateState(state, result);
      }
      return this.buildResponse(state);
    }

    async initializeDebate(message) {
      var alphaResponse;
      alphaResponse = (await this.alpha.processMessage(message, null));
      return {
        alphaResponse: alphaResponse,
        previousContent: this.extractContent(alphaResponse),
        betaResponse: null,
        round: 0
      };
    }

    async runDebateRound(message, state, round, recordComm) {
      var alphaRefined, betaContent, betaResponse, challengePrompt, refinePrompt, refinedContent;
      // Beta challenges
      challengePrompt = this.promptBuilder.buildDebateChallenge(message, state.previousContent);
      betaResponse = (await this.beta.processMessage(challengePrompt, state.previousContent));
      betaContent = this.extractContent(betaResponse);
      recordComm({
        from: 'beta',
        to: 'alpha',
        message: betaContent,
        type: 'challenge',
        round: round
      });
      // Alpha refines
      refinePrompt = this.promptBuilder.buildDebateRefine(message, state.previousContent, betaContent);
      alphaRefined = (await this.alpha.processMessage(refinePrompt, betaContent));
      refinedContent = this.extractContent(alphaRefined);
      recordComm({
        from: 'alpha',
        to: 'beta',
        message: refinedContent,
        type: 'refinement',
        round: round
      });
      return {
        betaResponse: betaResponse,
        alphaRefined: alphaRefined,
        refinedContent: refinedContent
      };
    }

    updateState(state, result) {
      return {
        ...state,
        alphaResponse: result.alphaRefined,
        betaResponse: result.betaResponse,
        previousContent: result.refinedContent,
        round: state.round + 1
      };
    }

    hasConverged(previous, current) {
      return this.calculateSimilarity(previous, current) > this.convergenceThreshold;
    }

    calculateSimilarity(text1, text2) {
      var commonWords, str1, str2, totalWords, words1, words2;
      str1 = String(text1).toLowerCase();
      str2 = String(text2).toLowerCase();
      words1 = str1.split(/\s+/);
      words2 = str2.split(/\s+/);
      commonWords = words1.filter(function(word) {
        return words2.includes(word);
      });
      totalWords = Math.max(words1.length, words2.length);
      if (totalWords > 0) {
        return commonWords.length / totalWords;
      } else {
        return 0;
      }
    }

    buildResponse(state) {
      return {
        alphaResponse: state.alphaResponse,
        betaResponse: state.betaResponse,
        rounds: state.round
      };
    }

  };

  // Synthesis Mode - Parallel processing then unified response
  SynthesisExecutor = class SynthesisExecutor extends ModeExecutor {
    constructor(alpha, beta, config) {
      super(alpha, beta, config);
      this.synthesisModel = config.modes.synthesis.synthesis_model;
      this.showIndividual = config.modes.synthesis.show_individual;
    }

    async execute(message, processId, recordComm) {
      var contents, parallelExecutor, parallelResult, synthesis;
      // Get both responses in parallel
      parallelExecutor = new ParallelExecutor(this.alpha, this.beta, this.config);
      parallelResult = (await parallelExecutor.execute(message, processId, recordComm));
      // Extract contents
      contents = {
        alpha: this.extractContent(parallelResult.alphaResponse),
        beta: this.extractContent(parallelResult.betaResponse)
      };
      // Synthesize
      synthesis = (await this.createSynthesis(message, contents, recordComm));
      // Build final response
      return this.buildResponse(parallelResult, synthesis);
    }

    async createSynthesis(message, contents, recordComm) {
      var synthesis, synthesisPrompt, synthesizer;
      synthesizer = this.synthesisModel === 'alpha' ? this.alpha : this.beta;
      synthesisPrompt = this.promptBuilder.buildSynthesisPrompt(message, contents);
      synthesis = (await synthesizer.processMessage(synthesisPrompt, contents));
      recordComm({
        from: 'both',
        to: 'synthesis',
        message: this.extractContent(synthesis),
        type: 'synthesis',
        inputs: contents
      });
      return synthesis;
    }

    buildResponse(parallelResult, synthesis) {
      return {
        alphaResponse: this.showIndividual ? parallelResult.alphaResponse : null,
        betaResponse: this.showIndividual ? parallelResult.betaResponse : null,
        synthesis: synthesis
      };
    }

  };

  // Handoff Mode - Conditional processing based on content
  HandoffExecutor = class HandoffExecutor extends ModeExecutor {
    constructor(alpha, beta, config) {
      super(alpha, beta, config);
      this.triggerPhrases = config.modes.handoff.trigger_phrases;
      this.setupSelectionRules();
    }

    setupSelectionRules() {
      return this.modelSelectionRules = {
        alpha: ['analyze', 'calculate', 'verify', 'facts', 'data', 'logical', 'step', 'method'],
        beta: ['create', 'imagine', 'design', 'alternative', 'innovative', 'brainstorm', 'idea']
      };
    }

    async execute(message, processId, recordComm) {
      var primaryContent, primaryModel, primaryResponse, startModel;
      startModel = this.selectStartModel(message);
      primaryModel = startModel === 'alpha' ? this.alpha : this.beta;
      primaryResponse = (await primaryModel.processMessage(message, null));
      primaryContent = this.extractContent(primaryResponse);
      if (this.shouldHandoff(primaryContent)) {
        return (await this.executeHandoff(message, startModel, primaryResponse, primaryContent, recordComm));
      } else {
        return this.buildSingleResponse(startModel, primaryResponse);
      }
    }

    selectStartModel(message) {
      var keywords, lowerMessage, model, ref, scores;
      scores = {
        alpha: 0,
        beta: 0
      };
      lowerMessage = message.toLowerCase();
      ref = this.modelSelectionRules;
      for (model in ref) {
        keywords = ref[model];
        scores[model] = keywords.filter(function(word) {
          return lowerMessage.includes(word);
        }).length;
      }
      if (scores.alpha >= scores.beta) {
        return 'alpha';
      } else {
        return 'beta';
      }
    }

    shouldHandoff(content) {
      var lowerContent;
      lowerContent = content.toLowerCase();
      return this.triggerPhrases.some(function(phrase) {
        return lowerContent.includes(phrase.toLowerCase());
      });
    }

    async executeHandoff(message, startModel, primaryResponse, primaryContent, recordComm) {
      var handoffPrompt, otherModel, otherModelName, secondaryResponse;
      otherModelName = startModel === 'alpha' ? 'beta' : 'alpha';
      otherModel = startModel === 'alpha' ? this.beta : this.alpha;
      handoffPrompt = this.promptBuilder.buildHandoffPrompt(message, startModel, primaryContent);
      secondaryResponse = (await otherModel.processMessage(handoffPrompt, primaryContent));
      recordComm({
        from: startModel,
        to: otherModelName,
        message: this.getHandoffReason(startModel),
        type: 'handoff'
      });
      return this.buildDualResponse(startModel, primaryResponse, secondaryResponse, otherModelName);
    }

    getHandoffReason(fromModel) {
      var reasons;
      reasons = {
        alpha: "Handing off for creative input",
        beta: "Handing off for analytical verification"
      };
      return reasons[fromModel];
    }

    buildSingleResponse(model, response) {
      return {
        alphaResponse: model === 'alpha' ? response : null,
        betaResponse: model === 'beta' ? response : null,
        primary: model
      };
    }

    buildDualResponse(startModel, firstResponse, secondResponse, primaryModel) {
      return {
        alphaResponse: startModel === 'alpha' ? firstResponse : secondResponse,
        betaResponse: startModel === 'beta' ? firstResponse : secondResponse,
        primary: primaryModel
      };
    }

  };

  // Prompt builder remains the same
  PromptBuilder = class PromptBuilder {
    buildDebateChallenge(message, alphaContent) {
      return `Original question: ${message}
Alpha's response: ${alphaContent}

Provide a creative challenge or alternative perspective to Alpha's response.
Focus on what might be missing, alternative approaches, or creative insights.`;
    }

    buildDebateRefine(message, alphaContent, betaContent) {
      return `Original question: ${message}
Your previous response: ${alphaContent}
Beta's challenge: ${betaContent}

Refine your response considering Beta's creative perspective.
Integrate valid points while maintaining analytical rigor.`;
    }

    buildSynthesisPrompt(message, contents) {
      return `Original question: ${message}

Alpha's analytical response: ${contents.alpha}
Beta's creative response: ${contents.beta}

Create a unified response that synthesizes both perspectives.
Combine the logical rigor of Alpha with the creative insights of Beta.
The result should be more complete than either individual response.`;
    }

    buildHandoffPrompt(message, fromModel, content) {
      var continuations, perspectives;
      perspectives = {
        alpha: "Alpha's initial analysis",
        beta: "Beta's creative perspective"
      };
      continuations = {
        alpha: "Please continue with a creative perspective.",
        beta: "Please provide analytical verification and structure."
      };
      return `${message}

${perspectives[fromModel]}: ${content}

${continuations[fromModel]}`;
    }

  };

  // RolePlay Mode - Character-based collaborative storytelling
  RolePlayExecutor = class RolePlayExecutor extends ModeExecutor {
    constructor(alpha, beta, config) {
      super(alpha, beta, config);
      this.character = null;
      this.scenario = null;
      this.worldInfo = null;
      this.messageHistory = [];
      this.maxContextMessages = 20;
    }

    setCharacter(characterCard) {
      this.character = this.parseCharacterCard(characterCard);
      this.scenario = characterCard.scenario || null;
      this.worldInfo = characterCard.world_info || null;
      this.messageHistory = [];
      // Add first greeting to message history if available
      if (this.character.first_mes) {
        this.messageHistory.push({
          role: 'assistant',
          content: this.character.first_mes,
          isOOC: false
        });
      }
      return console.log(`Character loaded: ${this.character.name}`);
    }

    parseCharacterCard(card) {
      return {
        // Support SillyTavern character card format
        name: card.name || 'Character',
        description: card.description || '',
        personality: card.personality || '',
        first_mes: card.first_mes || '',
        mes_example: card.mes_example || '',
        scenario: card.scenario || '',
        creator_notes: card.creator_notes || '',
        system_prompt: card.system_prompt || '',
        alternate_greetings: card.alternate_greetings || [],
        tags: card.tags || []
      };
    }

    execute(message, processId, recordComm, isOOC = false) {
      if (!this.character) {
        throw new Error("No character loaded. Please load a character card first.");
      }
      // Store the user message in history
      this.messageHistory.push({
        role: 'user',
        content: message,
        isOOC
      });
      if (isOOC) {
        // Handle OOC messages - brains discuss the character/scene
        return this.handleOOCMessage(message, processId, recordComm);
      } else {
        // Handle IC messages - generate in-character response
        return this.handleICMessage(message, processId, recordComm);
      }
    }

    async handleICMessage(message, processId, recordComm) {
      var alphaContent, alphaPrompt, alphaResult, betaContent, betaPrompt, betaResult, context, finalICResponse, promises, refinedResponse, refinementPrompt, results;
      // Build context for both brains
      context = this.buildCharacterContext();
      // Alpha analyzes character consistency and scene logic
      alphaPrompt = `${context}

As the analytical brain, analyze the current scene and ensure character consistency.
Consider: personality traits, established relationships, scene continuity.
User says: "${message}"

Provide brief OOC notes about how ${this.character.name} should respond.`;
      // Beta generates creative character response
      betaPrompt = `${context}

As the creative brain, embody ${this.character.name} and respond naturally.
Stay true to their voice, mannerisms, and emotional state.
User says: "${message}"

Respond as ${this.character.name} would, in character.`;
      // Get both responses in parallel
      promises = [this.alpha.processMessage(alphaPrompt, null), this.beta.processMessage(betaPrompt, null)];
      results = (await Promise.allSettled(promises));
      [alphaResult, betaResult] = results;
      // Extract responses
      alphaContent = alphaResult.status === 'fulfilled' ? this.extractContent(alphaResult.value) : null;
      betaContent = betaResult.status === 'fulfilled' ? this.extractContent(betaResult.value) : null;
      // Record Alpha's analysis as OOC communication
      if (alphaContent) {
        recordComm({
          from: 'alpha',
          to: 'ooc',
          message: alphaContent,
          type: 'character_analysis'
        });
      }
      // Beta refines response based on Alpha's analysis
      if (alphaContent && betaContent) {
        refinementPrompt = `${context}

Alpha's consistency notes: ${alphaContent}
Your initial response: ${betaContent}

Refine your response as ${this.character.name}, incorporating Alpha's insights while maintaining the character's authentic voice.`;
        refinedResponse = (await this.beta.processMessage(refinementPrompt, alphaContent));
        finalICResponse = this.extractContent(refinedResponse);
        recordComm({
          from: 'beta',
          to: 'alpha',
          message: 'Refined character response based on consistency analysis',
          type: 'refinement'
        });
      } else {
        finalICResponse = betaContent;
      }
      // Store the character's response in history
      this.messageHistory.push({
        role: 'assistant',
        content: finalICResponse,
        isOOC: false
      });
      // Trim history if too long
      if (this.messageHistory.length > this.maxContextMessages * 2) {
        this.messageHistory = this.messageHistory.slice(-this.maxContextMessages * 2);
      }
      return {
        alphaResponse: alphaContent, // OOC analysis
        betaResponse: betaContent, // Initial IC response
        icResponse: finalICResponse, // Final IC response
        character: this.character.name,
        isOOC: false
      };
    }

    async handleOOCMessage(message, processId, recordComm) {
      var alphaContent, alphaResult, betaContent, betaResult, oocPrompt, promises, ref, results;
      // Both brains discuss the scene/character out of character
      oocPrompt = `Character: ${this.character.name}
Description: ${this.character.description}
Current scenario: ${this.scenario || 'Not specified'}

OOC Discussion requested: ${message}

Provide your perspective on the character, scene, or story development.`;
      promises = [this.alpha.processMessage(oocPrompt + "\nAs Alpha, provide analytical insights about story structure, consistency, and character development.", null), this.beta.processMessage(oocPrompt + "\nAs Beta, provide creative ideas about potential plot twists, emotional depth, and character growth.", null)];
      results = (await Promise.allSettled(promises));
      [alphaResult, betaResult] = results;
      alphaContent = alphaResult.status === 'fulfilled' ? this.extractContent(alphaResult.value) : 'Alpha encountered an error';
      betaContent = betaResult.status === 'fulfilled' ? this.extractContent(betaResult.value) : 'Beta encountered an error';
      recordComm({
        from: 'both',
        to: 'ooc',
        message: 'Out-of-character discussion',
        type: 'ooc_discussion'
      });
      return {
        alphaResponse: alphaContent,
        betaResponse: betaContent,
        icResponse: null,
        character: (ref = this.character) != null ? ref.name : void 0,
        isOOC: true
      };
    }

    buildCharacterContext() {
      var characterName, recentHistory;
      if (!this.character) {
        return '';
      }
      // Build character context including recent history
      characterName = this.character.name;
      recentHistory = this.messageHistory.slice(-this.maxContextMessages).map(function(msg) {
        var role;
        role = msg.role === 'user' ? 'User' : characterName;
        return `${role}: ${msg.content}`;
      }).join('\n');
      return `Character: ${this.character.name}
Description: ${this.character.description}
Personality: ${this.character.personality}
${this.scenario ? `Scenario: ${this.scenario}` : ''}
${this.character.system_prompt ? `System: ${this.character.system_prompt}` : ''}

${recentHistory ? `Recent conversation:\n${recentHistory}` : ''}`;
    }

    resetConversation() {
      var ref, ref1;
      this.messageHistory = [];
      if ((ref = this.character) != null ? ref.first_mes : void 0) {
        this.messageHistory.push({
          role: 'assistant',
          content: this.character.first_mes,
          isOOC: false
        });
      }
      // Return the first message for display
      return (ref1 = this.character) != null ? ref1.first_mes : void 0;
    }

  };

  module.exports = {ModeExecutor, ParallelExecutor, SequentialExecutor, DebateExecutor, SynthesisExecutor, HandoffExecutor, RolePlayExecutor, PromptBuilder};

}).call(this);
