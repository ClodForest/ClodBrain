// Generated by CoffeeScript 2.7.0
(function() {
  // Corpus Callosum - Simplified orchestration using mode executors
  var CorpusCallosum, DebateExecutor, HandoffExecutor, ParallelExecutor, RolePlayExecutor, SequentialExecutor, SynthesisExecutor;

  ({ParallelExecutor, SequentialExecutor, DebateExecutor, SynthesisExecutor, HandoffExecutor, RolePlayExecutor} = require('./mode-executors'));

  CorpusCallosum = class CorpusCallosum {
    constructor(alpha, beta, config) {
      this.alpha = alpha;
      this.beta = beta;
      this.config = config;
      this.currentMode = this.config.default_mode;
      this.modeParameters = {};
      this.communicationHistory = [];
      this.activeProcesses = new Map();
      this.patterns = new Map();
      this.initializeExecutors();
      this.initializeClassifiers();
    }

    initializeExecutors() {
      return this.executors = {
        parallel: new ParallelExecutor(this.alpha, this.beta, this.config),
        sequential: new SequentialExecutor(this.alpha, this.beta, this.config),
        debate: new DebateExecutor(this.alpha, this.beta, this.config),
        synthesis: new SynthesisExecutor(this.alpha, this.beta, this.config),
        handoff: new HandoffExecutor(this.alpha, this.beta, this.config),
        roleplay: new RolePlayExecutor(this.alpha, this.beta, this.config)
      };
    }

    initializeClassifiers() {
      return this.messageClassifiers = [
        {
          pattern: /\b(how|what|why|when|where|who)\b/,
          type: 'question'
        },
        {
          pattern: /\b(create|make|design|build|generate)\b/,
          type: 'creation'
        },
        {
          pattern: /\b(analyze|examine|evaluate|assess|review)\b/,
          type: 'analysis'
        },
        {
          pattern: /\b(help|assist|support|guide)\b/,
          type: 'assistance'
        }
      ];
    }

    // Main orchestration method
    async orchestrate(userMessage, conversationId, mode = null, options = {}) {
      var activeMode, executor, process, processId, recordComm, result;
      activeMode = mode || this.currentMode;
      processId = this.generateProcessId();
      process = this.createProcess(processId, activeMode, userMessage, conversationId);
      this.activeProcesses.set(processId, process);
      try {
        executor = this.executors[activeMode];
        if (!executor) {
          throw new Error(`Unknown mode: ${activeMode}`);
        }
        // Create communication recorder for this process
        recordComm = (communication) => {
          return this.recordCommunication(processId, communication);
        };
        // Handle role-play specific options
        if (activeMode === 'roleplay') {
          // Pass isOOC flag if provided
          console.log(`Running roleplay mode (${options.isOOC ? 'OOC' : 'IC'}): ${userMessage}`);
          result = (await executor.execute(userMessage, processId, recordComm, options.isOOC));
        } else {
          // Execute the mode normally
          console.log(`Running ${activeMode} mode for: ${userMessage}`);
          result = (await executor.execute(userMessage, processId, recordComm, this.modeParameters));
        }
        // Finalize result
        result = this.finalizeResult(result, activeMode, processId);
        // Store pattern for learning
        this.storePattern(activeMode, userMessage, result);
        return result;
      } finally {
        this.activeProcesses.delete(processId);
      }
    }

    // Process management
    createProcess(id, mode, message, conversationId) {
      return {
        id: id,
        mode: mode,
        startTime: Date.now(),
        userMessage: message,
        conversationId: conversationId,
        communications: []
      };
    }

    finalizeResult(result, mode, processId) {
      return {
        ...result,
        mode: mode,
        communications: this.getProcessCommunications(processId),
        timestamp: new Date().toISOString()
      };
    }

    // Communication tracking
    recordCommunication(processId, communication) {
      var process;
      process = this.activeProcesses.get(processId);
      if (!process) {
        return;
      }
      communication.timestamp = Date.now();
      process.communications.push(communication);
      return this.communicationHistory.push({processId, ...communication});
    }

    getProcessCommunications(processId) {
      var ref;
      return ((ref = this.activeProcesses.get(processId)) != null ? ref.communications : void 0) || [];
    }

    // Pattern learning
    storePattern(mode, message, result) {
      var key, pattern, patterns;
      pattern = {
        mode: mode,
        messageType: this.classifyMessage(message),
        success: result != null,
        timestamp: Date.now()
      };
      key = `${pattern.mode}_${pattern.messageType}`;
      if (!this.patterns.has(key)) {
        this.patterns.set(key, []);
      }
      patterns = this.patterns.get(key);
      patterns.push(pattern);
      if (patterns.length > 100) {
        return this.patterns.set(key, patterns.slice(-100));
      }
    }

    classifyMessage(message) {
      var classifier, i, len, lowerMessage, ref;
      lowerMessage = message.toLowerCase();
      ref = this.messageClassifiers;
      for (i = 0, len = ref.length; i < len; i++) {
        classifier = ref[i];
        if (classifier.pattern.test(lowerMessage)) {
          return classifier.type;
        }
      }
      return 'general';
    }

    // Mode management
    setMode(mode, parameters = {}) {
      if (!this.executors[mode]) {
        throw new Error(`Invalid mode: ${mode}`);
      }
      this.currentMode = mode;
      this.modeParameters = parameters;
      return console.log(`Corpus Callosum mode changed to: ${mode}`);
    }

    // Character management for roleplay mode
    loadCharacter(characterCard) {
      var roleplayExecutor;
      roleplayExecutor = this.executors.roleplay;
      if (!roleplayExecutor) {
        throw new Error("Roleplay executor not initialized");
      }
      roleplayExecutor.setCharacter(characterCard);
      this.currentMode = 'roleplay';
      console.log("Character loaded for roleplay mode");
      return {
        // Return character info including first message
        name: characterCard.name,
        scenario: characterCard.scenario,
        first_mes: characterCard.first_mes
      };
    }

    resetRoleplay() {
      var firstMessage, roleplayExecutor;
      roleplayExecutor = this.executors.roleplay;
      if (roleplayExecutor) {
        firstMessage = roleplayExecutor.resetConversation();
        console.log("Roleplay conversation reset");
        return firstMessage;
      }
    }

    // Utilities
    generateProcessId() {
      return `proc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    interrupt() {
      console.log(`Interrupting ${this.activeProcesses.size} active processes`);
      return this.activeProcesses.clear();
    }

    getStats() {
      return {
        currentMode: this.currentMode,
        activeProcesses: this.activeProcesses.size,
        totalCommunications: this.communicationHistory.length,
        patterns: Object.fromEntries(this.patterns),
        availableModes: Object.keys(this.executors)
      };
    }

  };

  module.exports = CorpusCallosum;

}).call(this);
