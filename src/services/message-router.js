// Generated by CoffeeScript 2.7.0
(function() {
  // Message Router - Orchestrates message flow through the dual-brain system
  var MessageRouter;

  MessageRouter = class MessageRouter {
    constructor(corpusCallosum, neo4jTool) {
      this.corpusCallosum = corpusCallosum;
      this.neo4jTool = neo4jTool;
      this.activeConversations = new Map();
      this.messageHistory = [];
      this.interrupted = false;
    }

    async processMessage(message, mode = 'parallel', conversationId = null, options = {}) {
      var alphaContent, alphaMessage, betaContent, betaMessage, comm, conversation, error, i, icMessage, len, ref, result, synthesisContent, synthesisMessage, userMessage;
      try {
        // Generate conversation ID if not provided
        if (!conversationId) {
          conversationId = this.generateConversationId();
        }
        // Initialize conversation if new
        if (!this.activeConversations.has(conversationId)) {
          this.initializeConversation(conversationId);
        }
        conversation = this.activeConversations.get(conversationId);
        // Add user message to conversation
        userMessage = {
          id: this.generateMessageId(),
          content: message,
          sender: 'user',
          timestamp: new Date().toISOString(),
          conversationId: conversationId,
          isOOC: options.isOOC || false // Track if message is OOC
        };
        conversation.messages.push(userMessage);
        this.messageHistory.push(userMessage);
        // Store message in Neo4j
        await this.storeMessageInNeo4j(userMessage, conversation);
        // Process through corpus callosum
        result = (await this.corpusCallosum.orchestrate(message, conversationId, mode, options));
        // Store AI responses in conversation and Neo4j
        if (result.alphaResponse) {
          alphaContent = typeof result.alphaResponse === 'string' ? result.alphaResponse : result.alphaResponse.content;
          alphaMessage = {
            id: this.generateMessageId(),
            content: alphaContent,
            sender: 'alpha',
            model: 'alpha',
            timestamp: result.timestamp,
            conversationId: conversationId
          };
          conversation.messages.push(alphaMessage);
          this.messageHistory.push(alphaMessage);
          await this.storeMessageInNeo4j(alphaMessage, conversation);
        }
        if (result.betaResponse) {
          betaContent = typeof result.betaResponse === 'string' ? result.betaResponse : result.betaResponse.content;
          betaMessage = {
            id: this.generateMessageId(),
            content: betaContent,
            sender: 'beta',
            model: 'beta',
            timestamp: result.timestamp,
            conversationId: conversationId
          };
          conversation.messages.push(betaMessage);
          this.messageHistory.push(betaMessage);
          await this.storeMessageInNeo4j(betaMessage, conversation);
        }
        if (result.synthesis) {
          synthesisContent = typeof result.synthesis === 'string' ? result.synthesis : result.synthesis.content;
          synthesisMessage = {
            id: this.generateMessageId(),
            content: synthesisContent,
            sender: 'synthesis',
            model: 'synthesis',
            timestamp: result.timestamp,
            conversationId: conversationId
          };
          conversation.messages.push(synthesisMessage);
          this.messageHistory.push(synthesisMessage);
          await this.storeMessageInNeo4j(synthesisMessage, conversation);
        }
        // Handle roleplay IC responses
        if (result.icResponse) {
          icMessage = {
            id: this.generateMessageId(),
            content: result.icResponse,
            sender: 'character',
            character: result.character,
            model: 'roleplay',
            timestamp: result.timestamp,
            conversationId: conversationId,
            isOOC: false
          };
          conversation.messages.push(icMessage);
          this.messageHistory.push(icMessage);
          await this.storeMessageInNeo4j(icMessage, conversation);
        }
        // Update conversation metadata
        conversation.lastActivity = new Date().toISOString();
        conversation.mode = mode;
        conversation.messageCount = conversation.messages.length;
        // Store communications in Neo4j
        if (result.communications) {
          ref = result.communications;
          for (i = 0, len = ref.length; i < len; i++) {
            comm = ref[i];
            await this.storeCommunicationInNeo4j(comm, conversationId);
          }
        }
        // Extract and store knowledge from the conversation
        await this.extractAndStoreKnowledge(message, result, conversationId);
        return {
          conversationId: conversationId,
          userMessage: userMessage,
          ...result
        };
      } catch (error1) {
        error = error1;
        console.error('Message processing error:', error);
        throw error;
      }
    }

    initializeConversation(conversationId) {
      var conversation;
      conversation = {
        id: conversationId,
        startTime: new Date().toISOString(),
        lastActivity: new Date().toISOString(),
        messages: [],
        mode: 'parallel',
        messageCount: 0,
        participants: ['user', 'alpha', 'beta']
      };
      this.activeConversations.set(conversationId, conversation);
      
      // Store conversation in Neo4j
      this.storeConversationInNeo4j(conversation);
      return conversation;
    }

    async storeConversationInNeo4j(conversation) {
      var error, query;
      try {
        query = `CREATE (c:Conversation {
  id: $id,
  startTime: $startTime,
  lastActivity: $lastActivity,
  mode: $mode,
  messageCount: $messageCount,
  participants: $participants
})
RETURN c`;
        return (await this.neo4jTool.executeQuery(query, {
          id: conversation.id,
          startTime: conversation.startTime,
          lastActivity: conversation.lastActivity,
          mode: conversation.mode,
          messageCount: conversation.messageCount,
          participants: conversation.participants
        }));
      } catch (error1) {
        error = error1;
        return console.error('Failed to store conversation in Neo4j:', error);
      }
    }

    async storeMessageInNeo4j(message, conversation) {
      var error, query;
      try {
        query = `MATCH (c:Conversation {id: $conversationId})
CREATE (m:Message {
  id: $id,
  content: $content,
  sender: $sender,
  model: $model,
  timestamp: $timestamp,
  conversationId: $conversationId
})
CREATE (c)-[:CONTAINS]->(m)
RETURN m`;
        return (await this.neo4jTool.executeQuery(query, {
          id: message.id,
          content: message.content,
          sender: message.sender,
          model: message.model || message.sender, // Ensure it's a string
          timestamp: message.timestamp,
          conversationId: message.conversationId
        }));
      } catch (error1) {
        error = error1;
        return console.error('Failed to store message in Neo4j:', error);
      }
    }

    async storeCommunicationInNeo4j(communication, conversationId) {
      var error, query;
      try {
        // Flatten the communication object to primitive values only
        query = `MATCH (c:Conversation {id: $conversationId})
CREATE (comm:Communication {
  id: $id,
  fromBrain: $fromBrain,
  toBrain: $toBrain,
  content: $content,
  type: $type,
  timestamp: $timestamp,
  conversationId: $conversationId
})
CREATE (c)-[:HAS_COMMUNICATION]->(comm)
RETURN comm`;
        return (await this.neo4jTool.executeQuery(query, {
          id: this.generateMessageId(),
          fromBrain: String(communication.from || 'unknown'),
          toBrain: String(communication.to || 'unknown'),
          content: String(communication.message || communication.content || ''),
          type: String(communication.type || 'general'),
          timestamp: new Date(communication.timestamp || Date.now()).toISOString(),
          conversationId: String(conversationId)
        }));
      } catch (error1) {
        error = error1;
        return console.error('Failed to store communication in Neo4j:', error);
      }
    }

    async extractAndStoreKnowledge(userMessage, result, conversationId) {
      var concept, concepts, entities, entity, error, i, j, len, len1, results;
      try {
        // Extract entities and concepts from the conversation
        entities = this.extractEntities(userMessage, result);
        concepts = this.extractConcepts(userMessage, result);

        // Store entities
        for (i = 0, len = entities.length; i < len; i++) {
          entity = entities[i];
          await this.storeEntityInNeo4j(entity, conversationId);
        }

        // Store concepts
        results = [];
        for (j = 0, len1 = concepts.length; j < len1; j++) {
          concept = concepts[j];
          results.push((await this.storeConceptInNeo4j(concept, conversationId)));
        }
        return results;
      } catch (error1) {
        error = error1;
        return console.error('Failed to extract and store knowledge:', error);
      }
    }

    extractEntities(userMessage, result) {
      var content, entities, i, len, match, matches;
      entities = [];
      
      // Simple entity extraction (in production, use proper NLP)
      content = `${userMessage} ${result.alphaResponse || ''} ${result.betaResponse || ''}`;
      
      // Extract capitalized words as potential entities
      matches = content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b/g) || [];
      for (i = 0, len = matches.length; i < len; i++) {
        match = matches[i];
        if (match.length > 2 && !this.isCommonWord(match)) {
          entities.push({
            name: match,
            type: 'entity',
            confidence: 0.7,
            extractedFrom: 'conversation'
          });
        }
      }
      return entities;
    }

    extractConcepts(userMessage, result) {
      var conceptPatterns, concepts, content, i, j, len, len1, match, matches, pattern;
      concepts = [];
      
      // Extract potential concepts (simplified approach)
      content = `${userMessage} ${result.alphaResponse || ''} ${result.betaResponse || ''}`;
      
      // Look for conceptual terms
      conceptPatterns = [
        /\b(\w+ing)\b/g, // gerunds
        /\b(\w+tion)\b/g, // action nouns
        /\b(\w+ment)\b/g, // state nouns
        /\b(\w+ness)\b/g // quality nouns
      ];
      for (i = 0, len = conceptPatterns.length; i < len; i++) {
        pattern = conceptPatterns[i];
        matches = content.match(pattern) || [];
        for (j = 0, len1 = matches.length; j < len1; j++) {
          match = matches[j];
          if (match.length > 4 && !this.isCommonWord(match)) {
            concepts.push({
              name: match,
              type: 'concept',
              domain: 'general',
              extractedFrom: 'conversation'
            });
          }
        }
      }
      return concepts;
    }

    async storeEntityInNeo4j(entity, conversationId) {
      var error, query;
      try {
        query = `MERGE (e:Entity {name: $name})
ON CREATE SET e.type = $type, e.confidence = $confidence, e.created = timestamp()
ON MATCH SET e.confidence = (e.confidence + $confidence) / 2

WITH e
MATCH (c:Conversation {id: $conversationId})
MERGE (c)-[:MENTIONS]->(e)
RETURN e`;
        return (await this.neo4jTool.executeQuery(query, {
          name: entity.name,
          type: entity.type,
          confidence: entity.confidence,
          conversationId: conversationId
        }));
      } catch (error1) {
        error = error1;
        return console.error('Failed to store entity in Neo4j:', error);
      }
    }

    async storeConceptInNeo4j(concept, conversationId) {
      var error, query;
      try {
        query = `MERGE (c:Concept {name: $name})
ON CREATE SET c.type = $type, c.domain = $domain, c.created = timestamp()

WITH c
MATCH (conv:Conversation {id: $conversationId})
MERGE (conv)-[:DISCUSSES]->(c)
RETURN c`;
        return (await this.neo4jTool.executeQuery(query, {
          name: concept.name,
          type: concept.type,
          domain: concept.domain,
          conversationId: conversationId
        }));
      } catch (error1) {
        error = error1;
        return console.error('Failed to store concept in Neo4j:', error);
      }
    }

    isCommonWord(word) {
      var commonWords;
      commonWords = ['The', 'This', 'That', 'These', 'Those', 'When', 'Where', 'Who', 'What', 'Why', 'How', 'Yes', 'No', 'Can', 'Will', 'Should', 'Could', 'Would', 'But', 'And', 'Or', 'So', 'Because', 'Since', 'While', 'During', 'Before', 'After'];
      return commonWords.includes(word);
    }

    getConversation(conversationId) {
      return this.activeConversations.get(conversationId);
    }

    getAllConversations() {
      return Array.from(this.activeConversations.values());
    }

    getMessageHistory(limit = 100) {
      return this.messageHistory.slice(-limit);
    }

    interrupt() {
      this.interrupted = true;
      this.corpusCallosum.interrupt();
      return console.log('Message router interrupted');
    }

    clearInterrupt() {
      return this.interrupted = false;
    }

    generateConversationId() {
      return `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    generateMessageId() {
      return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    getStats() {
      return {
        activeConversations: this.activeConversations.size,
        totalMessages: this.messageHistory.length,
        interrupted: this.interrupted,
        corpusStats: this.corpusCallosum.getStats()
      };
    }

    // Character management methods for roleplay
    loadCharacter(characterCard) {
      // Returns character info including first message
      return this.corpusCallosum.loadCharacter(characterCard);
    }

    resetRoleplay() {
      // Returns the first message if available
      return this.corpusCallosum.resetRoleplay();
    }

  };

  module.exports = MessageRouter;

}).call(this);
