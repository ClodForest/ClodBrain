// Generated by CoffeeScript 2.7.0
(function() {
  var CorpusCallosum, DualLLMApp, LLMAlpha, LLMBeta, MessageRouter, Neo4jTool, Server, databaseConfig, express, http, isoDateString, modelsConfig, ollamaConfig, path, startApp;

  express = require('express');

  http = require('http');

  ({Server} = require('socket.io'));

  path = require('path');

  require('dotenv/config');

  LLMAlpha = require('./services/llm-alpha');

  LLMBeta = require('./services/llm-beta');

  CorpusCallosum = require('./services/corpus-callosum');

  Neo4jTool = require('./services/neo4j-tool');

  MessageRouter = require('./services/message-router');

  databaseConfig = require('./config/database');

  ollamaConfig = require('./config/ollama');

  modelsConfig = require('./config/models');

  isoDateString = function() {
    return new Date().toISOString();
  };

  DualLLMApp = class DualLLMApp {
    constructor() {
      this.app = express();
      this.server = http.createServer(this.app);
      this.io = new Server(this.server, {
        cors: {
          origin: "*",
          methods: ["GET", "POST"]
        }
      });
      this.port = process.env.PORT || 3000;
    }

    async initialize() {
      await this.initializeServices();
      this.setupMiddleware();
      this.setupRoutes();
      this.setupWebSockets();
      return this.setupErrorHandling();
    }

    async initializeServices() {
      console.log('Initializing services...');
      this.neo4jTool = new Neo4jTool(databaseConfig);
      await this.neo4jTool.connect();
      this.llmAlpha = new LLMAlpha(modelsConfig.alpha, ollamaConfig, this.neo4jTool);
      this.llmBeta = new LLMBeta(modelsConfig.beta, ollamaConfig, this.neo4jTool);
      this.corpusCallosum = new CorpusCallosum(this.llmAlpha, this.llmBeta, modelsConfig.corpus_callosum);
      return this.messageRouter = new MessageRouter(this.corpusCallosum, this.neo4jTool);
    }

    setupMiddleware() {
      // CORS handling
      this.app.use(function(req, res, next) {
        res.header('Access-Control-Allow-Origin', '*');
        res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
        res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, Content-Length, X-Requested-With');
        if (req.method === 'OPTIONS') {
          return res.sendStatus(200);
        } else {
          return next();
        }
      });
      // Security headers
      this.app.use(function(req, res, next) {
        res.setHeader('X-Content-Type-Options', 'nosniff');
        res.setHeader('X-Frame-Options', 'DENY');
        res.setHeader('X-XSS-Protection', '1; mode=block');
        return next();
      });
      // Request logging
      this.app.use(function(req, res, next) {
        console.log(`${isoDateString()} ${req.method} ${req.url}`);
        return next();
      });
      this.app.use(express.json({
        limit: '10mb'
      }));
      this.app.use(express.urlencoded({
        extended: true
      }));
      this.app.use(express.static(path.join(__dirname, '../public')));
      // Make services available to routes
      this.app.locals.messageRouter = this.messageRouter;
      this.app.locals.neo4jTool = this.neo4jTool;
      return this.app.locals.corpusCallosum = this.corpusCallosum;
    }

    setupRoutes() {
      this.app.post('/api/chat/message', async(req, res) => {
        var conversationId, error, message, mode, result;
        try {
          ({message, mode = 'parallel', conversationId} = req.body);
          result = (await this.messageRouter.processMessage(message, mode, conversationId));
          return res.json(result);
        } catch (error1) {
          error = error1;
          console.error('Chat API error:', error);
          return res.status(500).json({
            error: error.message
          });
        }
      });
      this.app.get('/api/chat/history/:id', (req, res) => {
        var conversation, error;
        try {
          conversation = this.messageRouter.getConversation(req.params.id);
          return res.json(conversation || {
            error: 'Conversation not found'
          });
        } catch (error1) {
          error = error1;
          console.error('History API error:', error);
          return res.status(500).json({
            error: error.message
          });
        }
      });
      this.app.get('/api/models', async(req, res) => {
        var alphaInfo, betaInfo, error;
        try {
          alphaInfo = (await this.llmAlpha.getModelInfo());
          betaInfo = (await this.llmBeta.getModelInfo());
          return res.json({
            alpha: alphaInfo,
            beta: betaInfo
          });
        } catch (error1) {
          error = error1;
          console.error('Models API error:', error);
          return res.status(500).json({
            error: error.message
          });
        }
      });
      this.app.post('/api/neo4j/query', async(req, res) => {
        var error, parameters, query, result;
        try {
          ({query, parameters = {}} = req.body);
          result = (await this.neo4jTool.executeQuery(query, parameters));
          return res.json(result);
        } catch (error1) {
          error = error1;
          console.error('Neo4j API error:', error);
          return res.status(500).json({
            error: error.message
          });
        }
      });
      this.app.get('/', function(req, res) {
        return res.sendFile(path.join(__dirname, '../public/index.html'));
      });
      return this.app.get('/health', async(req, res) => {
        var alphaHealth, betaHealth, error;
        try {
          alphaHealth = (await this.llmAlpha.healthCheck());
          betaHealth = (await this.llmBeta.healthCheck());
          return res.json({
            status: 'ok',
            timestamp: isoDateString(),
            services: {
              alpha: alphaHealth.status,
              beta: betaHealth.status,
              neo4j: 'connected' // TODO: actual health check
            }
          });
        } catch (error1) {
          error = error1;
          return res.status(500).json({
            status: 'error',
            error: error.message,
            timestamp: isoDateString()
          });
        }
      });
    }

    setupWebSockets() {
      return this.io.on('connection', (socket) => {
        console.log('User connected:', socket.id);
        socket.on('message_send', (data) => {
          return this.handleUserMessage(socket, data);
        });
        socket.on('orchestration_change', (data) => {
          return this.handleOrchestrationChange(socket, data);
        });
        socket.on('neo4j_query', (data) => {
          return this.handleNeo4jQuery(socket, data);
        });
        socket.on('model_interrupt', (data) => {
          return this.handleModelInterrupt(socket, data);
        });
        socket.on('load_character', (data) => {
          return this.handleLoadCharacter(socket, data);
        });
        socket.on('reset_roleplay', (data) => {
          return this.handleResetRoleplay(socket, data);
        });
        return socket.on('disconnect', function() {
          return console.log('User disconnected:', socket.id);
        });
      });
    }

    async handleUserMessage(socket, data) {
      var alphaContent, betaContent, comm, conversationId, error, i, isOOC, len, message, mode, options, ref, ref1, result, synthesisContent;
      try {
        ({message, mode = 'parallel', conversationId, isOOC} = data);
        console.log(`Processing message: ${message} in mode: ${mode}${isOOC ? ' (OOC)' : ''}`);
        options = {};
        if (mode === 'roleplay') {
          options.isOOC = isOOC;
        }
        result = (await this.messageRouter.processMessage(message, mode, conversationId, options));
        console.log("Result from message router:", {
          hasAlpha: !!result.alphaResponse,
          hasBeta: !!result.betaResponse,
          hasSynthesis: !!result.synthesis,
          alphaType: typeof result.alphaResponse,
          betaType: typeof result.betaResponse
        });
        // Clear thinking indicators for non-responding brains in handoff mode
        if (mode === 'handoff') {
          if (!result.alphaResponse) {
            socket.emit('clear_alpha_thinking');
          }
          if (!result.betaResponse) {
            socket.emit('clear_beta_thinking');
          }
        }
        // Emit Alpha response
        if (result.alphaResponse) {
          alphaContent = this.extractContent(result.alphaResponse);
          console.log("Sending alpha response:", (alphaContent != null ? alphaContent.substring(0, 100) : void 0) + "...");
          socket.emit('alpha_response', {
            content: alphaContent,
            timestamp: isoDateString(),
            model: this.llmAlpha.model
          });
        }
        // Emit Beta response
        if (result.betaResponse) {
          betaContent = this.extractContent(result.betaResponse);
          console.log("Beta response object:", JSON.stringify(result.betaResponse, null, 2));
          console.log("Beta content extracted:", (betaContent != null ? betaContent.substring(0, 100) : void 0) + "...");
          socket.emit('beta_response', {
            content: betaContent,
            timestamp: isoDateString(),
            model: this.llmBeta.model
          });
        }
        // Emit synthesis if present
        if (result.synthesis) {
          synthesisContent = this.extractContent(result.synthesis);
          console.log("Sending synthesis:", (synthesisContent != null ? synthesisContent.substring(0, 100) : void 0) + "...");
          socket.emit('synthesis_complete', {
            content: synthesisContent,
            timestamp: isoDateString(),
            mode: mode
          });
        }
        // Emit IC response for roleplay mode
        if (result.icResponse) {
          console.log(`Sending IC response from ${result.character}: ${(ref = result.icResponse) != null ? ref.substring(0, 100) : void 0}...`);
          socket.emit('ic_response', {
            content: result.icResponse,
            character: result.character,
            timestamp: isoDateString(),
            isOOC: result.isOOC
          });
        }
        // Emit corpus callosum communications
        if (result.communications) {
          ref1 = result.communications;
          for (i = 0, len = ref1.length; i < len; i++) {
            comm = ref1[i];
            socket.emit('corpus_communication', comm);
          }
        }
        // Signal completion for non-synthesis modes
        if ((mode === 'parallel' || mode === 'handoff' || mode === 'sequential') && !result.synthesis) {
          return socket.emit('interaction_complete', {
            mode: mode,
            primary: result.primary // For handoff mode
          });
        }
      } catch (error1) {
        error = error1;
        console.error('Error handling user message:', error);
        return socket.emit('error', {
          message: error.message
        });
      }
    }

    handleOrchestrationChange(socket, data) {
      var error, mode, parameters;
      try {
        ({mode, parameters} = data);
        this.corpusCallosum.setMode(mode, parameters);
        return socket.emit('orchestration_changed', {mode, parameters});
      } catch (error1) {
        error = error1;
        console.error('Error changing orchestration:', error);
        return socket.emit('error', {
          message: error.message
        });
      }
    }

    async handleNeo4jQuery(socket, data) {
      var error, parameters, query, result;
      try {
        ({query, parameters = {}} = data);
        result = (await this.neo4jTool.executeQuery(query, parameters));
        return socket.emit('neo4j_result', result);
      } catch (error1) {
        error = error1;
        console.error('Error executing Neo4j query:', error);
        return socket.emit('error', {
          message: error.message
        });
      }
    }

    handleModelInterrupt(socket, data) {
      var error;
      try {
        this.messageRouter.interrupt();
        return socket.emit('models_interrupted');
      } catch (error1) {
        error = error1;
        console.error('Error interrupting models:', error);
        return socket.emit('error', {
          message: error.message
        });
      }
    }

    handleLoadCharacter(socket, characterCard) {
      var characterInfo, error;
      try {
        characterInfo = this.messageRouter.loadCharacter(characterCard);
        socket.emit('character_loaded', characterInfo);
        return console.log(`Character loaded: ${characterInfo.name}`);
      } catch (error1) {
        error = error1;
        console.error('Error loading character:', error);
        return socket.emit('error', {
          message: error.message
        });
      }
    }

    handleResetRoleplay(socket, data) {
      var error, firstMessage;
      try {
        firstMessage = this.messageRouter.resetRoleplay();
        socket.emit('roleplay_reset', {
          first_mes: firstMessage
        });
        return console.log("Roleplay conversation reset");
      } catch (error1) {
        error = error1;
        console.error('Error resetting roleplay:', error);
        return socket.emit('error', {
          message: error.message
        });
      }
    }

    extractContent(response) {
      if (typeof response === 'string') {
        return response;
      } else {
        return response.content;
      }
    }

    setupErrorHandling() {
      this.app.use(function(error, req, res, next) {
        console.error('Unhandled error:', error);
        return res.status(500).json({
          error: 'Internal server error',
          message: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong'
        });
      });
      process.on('uncaughtException', function(error) {
        console.error('Uncaught Exception:', error);
        return process.exit(1);
      });
      return process.on('unhandledRejection', function(reason, promise) {
        console.error('Unhandled Rejection at:', promise, 'reason:', reason);
        return process.exit(1);
      });
    }

    start() {
      return this.server.listen(this.port, () => {
        return console.log(`ðŸ§  Dual-LLM Chat System Started ðŸ§ 
Port:        ${this.port}
Environment: ${process.env.NODE_ENV || 'development'}
Alpha Model: ${this.llmAlpha.model}
Beta Model:  ${this.llmBeta.model}
Neo4j:       ${process.env.NEO4J_URI || 'bolt://localhost:7687'}
Ollama:      ${process.env.OLLAMA_HOST || 'localhost:11434'}`);
      });
    }

  };

  // Start the application
  startApp = async function() {
    var app;
    app = new DualLLMApp();
    await app.initialize();
    return app.start();
  };

  startApp().catch(function(error) {
    console.error('Failed to start ClodBrain:', error);
    return process.exit(1);
  });

  module.exports = DualLLMApp;

}).call(this);
